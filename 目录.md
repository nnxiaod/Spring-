目录

[I. Spring 框架概要](https://github.com/nnxiaod/Spring-/tree/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81)
    
[1. 开始使用Spring](https://github.com/nnxiaod/Spring-/blob/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81/1%20%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8Spring.md#1-%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8spring)

[2. Spring 框架介绍](https://github.com/nnxiaod/Spring-/blob/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81/2%20Spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D.md#2-spring%E6%A1%86%E6%9E%B6%E4%BB%8B%E7%BB%8D)

[2.1. 依赖注入和控制反转](https://github.com/nnxiaod/Spring-/blob/master/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%20Spring%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A6%81/2.1%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC.md#21-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC)
        
2.2. 框架模块

2.2.1. 核心容器

2.2.2. AOP and Instrumentation

2.2.3. Messaging

2.2.4. Data Access/Integration

2.2.5. Web

2.2.6. 测试

2.3. Usage scenarios

            2.3.1. Dependency Management and Naming Conventions

                Spring Dependencies and Depending on Spring
                Maven Dependency Management
                Maven "Bill Of Materials" Dependency
                Gradle Dependency Management
                Ivy Dependency Management
                Distribution Zip Files

            2.3.2. Logging

                Using Log4j 1.2 or 2.x
                Avoiding Commons Logging
                Using SLF4J with Log4j or Logback
                Using JUL (java.util.logging)
                Commons Logging on WebSphere

II. Spring 框架 4.x 版本中的新内容

    3. 新特性和增强 in Spring Framework 4.0

        3.1. Improved Getting Started Experience
        3.2. Removed Deprecated Packages and Methods
        3.3. Java 8 (as well as 6 and 7)
        3.4. Java EE 6 and 7
        3.5. Groovy Bean Definition DSL
        3.6. Core Container Improvements
        3.7. General Web Improvements
        3.8. WebSocket, SockJS, and STOMP Messaging
        3.9. Testing Improvements

    4. New Features and Enhancements in Spring Framework 4.1

        4.1. JMS Improvements
        4.2. Caching Improvements
        4.3. Web Improvements
        4.4. WebSocket Messaging Improvements
        4.5. Testing Improvements

    5. New Features and Enhancements in Spring Framework 4.2

        5.1. Core Container Improvements
        5.2. Data Access Improvements
        5.3. JMS Improvements
        5.4. Web Improvements
        5.5. WebSocket Messaging Improvements
        5.6. Testing Improvements

    6. New Features and Enhancements in Spring Framework 4.3

        6.1. Core Container Improvements
        6.2. Data Access Improvements
        6.3. Caching Improvements
        6.4. JMS Improvements
        6.5. Web Improvements
        6.6. WebSocket Messaging Improvements
        6.7. Testing Improvements
        6.8. Support for new library and server generations

III. 核心技术

    7. IoC容器

        7.1. Introduction to the Spring IoC container and beans
        7.2. Container overview

            7.2.1. Configuration metadata
            7.2.2. Instantiating a container

                Composing XML-based configuration metadata
                The Groovy Bean Definition DSL

            7.2.3. Using the container

        7.3. Bean 概要

            7.3.1. Naming beans

                Aliasing a bean outside the bean definition

            7.3.2. Instantiating beans

                Instantiation with a constructor
                Instantiation with a static factory method
                Instantiation using an instance factory method

        7.4. Dependencies

            7.4.1. Dependency Injection

                Constructor-based dependency injection
                Setter-based dependency injection
                Dependency resolution process
                Examples of dependency injection

            7.4.2. Dependencies and configuration in detail

                Straight values (primitives, Strings, and so on)
                References to other beans (collaborators)
                Inner beans
                Collections
                Null and empty string values
                XML shortcut with the p-namespace
                XML shortcut with the c-namespace
                Compound property names

            7.4.3. Using depends-on
            7.4.4. Lazy-initialized beans
            7.4.5. Autowiring collaborators

                Limitations and disadvantages of autowiring
                Excluding a bean from autowiring

            7.4.6. Method injection

                Lookup method injection
                Arbitrary method replacement

        7.5. Bean scopes

            7.5.1. The singleton scope
            7.5.2. The prototype scope
            7.5.3. Singleton beans with prototype-bean dependencies
            7.5.4. Request, session, global session, application, and WebSocket scopes

                Initial web configuration
                Request scope
                Session scope
                Global session scope
                Application scope
                Scoped beans as dependencies

            7.5.5. Custom scopes

                Creating a custom scope
                Using a custom scope

        7.6. Customizing the nature of a bean

            7.6.1. Lifecycle callbacks

                Initialization callbacks
                Destruction callbacks
                Default initialization and destroy methods
                Combining lifecycle mechanisms
                Startup and shutdown callbacks
                Shutting down the Spring IoC container gracefully in non-web applications

            7.6.2. ApplicationContextAware and BeanNameAware
            7.6.3. Other Aware interfaces

        7.7. Bean definition inheritance
        7.8. Container Extension Points

            7.8.1. Customizing beans using a BeanPostProcessor

                Example: Hello World, BeanPostProcessor-style
                Example: The RequiredAnnotationBeanPostProcessor

            7.8.2. Customizing configuration metadata with a BeanFactoryPostProcessor

                Example: the Class name substitution PropertyPlaceholderConfigurer
                Example: the PropertyOverrideConfigurer

            7.8.3. Customizing instantiation logic with a FactoryBean

        7.9. Annotation-based container configuration

            7.9.1. @Required
            7.9.2. @Autowired
            7.9.3. Fine-tuning annotation-based autowiring with @Primary
            7.9.4. Fine-tuning annotation-based autowiring with qualifiers
            7.9.5. Using generics as autowiring qualifiers
            7.9.6. CustomAutowireConfigurer
            7.9.7. @Resource
            7.9.8. @PostConstruct and @PreDestroy

        7.10. Classpath scanning and managed components

            7.10.1. @Component and further stereotype annotations
            7.10.2. Meta-annotations
            7.10.3. Automatically detecting classes and registering bean definitions
            7.10.4. Using filters to customize scanning
            7.10.5. Defining bean metadata within components
            7.10.6. Naming autodetected components
            7.10.7. Providing a scope for autodetected components
            7.10.8. Providing qualifier metadata with annotations

        7.11. Using JSR 330 Standard Annotations

            7.11.1. Dependency Injection with @Inject and @Named
            7.11.2. @Named and @ManagedBean: standard equivalents to the @Component annotation
            7.11.3. Limitations of JSR-330 standard annotations

        7.12. Java-based container configuration

            7.12.1. Basic concepts: @Bean and @Configuration
            7.12.2. Instantiating the Spring container using AnnotationConfigApplicationContext

                Simple construction
                Building the container programmatically using register(Class<?>???)
                Enabling component scanning with scan(String???)
                Support for web applications with AnnotationConfigWebApplicationContext

            7.12.3. Using the @Bean annotation

                Declaring a bean
                Bean dependencies
                Receiving lifecycle callbacks
                Specifying bean scope
                Customizing bean naming
                Bean aliasing
                Bean description

            7.12.4. Using the @Configuration annotation

                Injecting inter-bean dependencies
                Lookup method injection
                Further information about how Java-based configuration works internally

            7.12.5. Composing Java-based configurations

                Using the @Import annotation
                Conditionally include @Configuration classes or @Bean methods
                Combining Java and XML configuration

        7.13. Environment abstraction

            7.13.1. Bean definition profiles

                @Profile
                XML bean definition profiles
                Activating a profile
                Default profile

            7.13.2. PropertySource abstraction
            7.13.3. @PropertySource
            7.13.4. Placeholder resolution in statements

        7.14. Registering a LoadTimeWeaver
        7.15. Additional Capabilities of the ApplicationContext

            7.15.1. Internationalization using MessageSource
            7.15.2. Standard and Custom Events

                Annotation-based Event Listeners
                Asynchronous Listeners
                Ordering Listeners
                Generic Events

            7.15.3. Convenient access to low-level resources
            7.15.4. Convenient ApplicationContext instantiation for web applications
            7.15.5. Deploying a Spring ApplicationContext as a Java EE RAR file

        7.16. The BeanFactory

            7.16.1. BeanFactory or ApplicationContext?
            7.16.2. Glue code and the evil singleton

    8. Resources

        8.1. Introduction
        8.2. The Resource interface
        8.3. Built-in Resource implementations

            8.3.1. UrlResource
            8.3.2. ClassPathResource
            8.3.3. FileSystemResource
            8.3.4. ServletContextResource
            8.3.5. InputStreamResource
            8.3.6. ByteArrayResource

        8.4. The ResourceLoader
        8.5. The ResourceLoaderAware interface
        8.6. Resources as dependencies
        8.7. Application contexts and Resource paths

            8.7.1. Constructing application contexts

                Constructing ClassPathXmlApplicationContext instances - shortcuts

            8.7.2. Wildcards in application context constructor resource paths

                Ant-style Patterns
                The Classpath*: portability classpath*: prefix
                Other notes relating to wildcards

            8.7.3. FileSystemResource caveats

    9. Validation, Data Binding, and Type Conversion

        9.1. Introduction
        9.2. Validation using Spring??s Validator interface
        9.3. Resolving codes to error messages
        9.4. Bean manipulation and the BeanWrapper

            9.4.1. Setting and getting basic and nested properties
            9.4.2. Built-in PropertyEditor implementations

                Registering additional custom PropertyEditors

        9.5. Spring Type Conversion

            9.5.1. Converter SPI
            9.5.2. ConverterFactory
            9.5.3. GenericConverter

                ConditionalGenericConverter

            9.5.4. ConversionService API
            9.5.5. Configuring a ConversionService
            9.5.6. Using a ConversionService programmatically

        9.6. Spring Field Formatting

            9.6.1. Formatter SPI
            9.6.2. Annotation-driven Formatting

                Format Annotation API

            9.6.3. FormatterRegistry SPI
            9.6.4. FormatterRegistrar SPI
            9.6.5. Configuring Formatting in Spring MVC

        9.7. Configuring a global date & time format
        9.8. Spring Validation

            9.8.1. Overview of the JSR-303 Bean Validation API
            9.8.2. Configuring a Bean Validation Provider

                Injecting a Validator
                Configuring Custom Constraints
                Spring-driven Method Validation
                Additional Configuration Options

            9.8.3. Configuring a DataBinder
            9.8.4. Spring MVC 3 Validation

    10. Spring 表达式语言 (SpEL)

        10.1. Introduction
        10.2. Feature Overview
        10.3. Expression Evaluation using Spring??s Expression Interface

            10.3.1. The EvaluationContext interface

                Type Conversion

            10.3.2. Parser configuration
            10.3.3. SpEL compilation

                Compiler configuration
                Compiler limitations

        10.4. Expression support for defining bean definitions

            10.4.1. XML based configuration
            10.4.2. Annotation-based configuration

        10.5. Language Reference

            10.5.1. Literal expressions
            10.5.2. Properties, Arrays, Lists, Maps, Indexers
            10.5.3. Inline lists
            10.5.4. Inline Maps
            10.5.5. Array construction
            10.5.6. Methods
            10.5.7. Operators

                Relational operators
                Logical operators
                Mathematical operators

            10.5.8. Assignment
            10.5.9. Types
            10.5.10. Constructors
            10.5.11. Variables

                The #this and #root variables

            10.5.12. Functions
            10.5.13. Bean references
            10.5.14. Ternary Operator (If-Then-Else)
            10.5.15. The Elvis Operator
            10.5.16. Safe Navigation operator
            10.5.17. Collection Selection
            10.5.18. Collection Projection
            10.5.19. Expression templating

        10.6. Classes used in the examples

    11. Spring中的面向切面编程（AOP）

        11.1. 介绍

            11.1.1. AOP concepts
            11.1.2. Spring AOP capabilities and goals
            11.1.3. AOP Proxies

        11.2. @AspectJ support

            11.2.1. Enabling @AspectJ Support

                Enabling @AspectJ Support with Java configuration
                Enabling @AspectJ Support with XML configuration

            11.2.2. Declaring an aspect
            11.2.3. Declaring a pointcut

                Supported Pointcut Designators
                Combining pointcut expressions
                Sharing common pointcut definitions
                Examples
                Writing good pointcuts

            11.2.4. Declaring advice

                Before advice
                After returning advice
                After throwing advice
                After (finally) advice
                Around advice
                Advice parameters
                Advice ordering

            11.2.5. Introductions
            11.2.6. Aspect instantiation models
            11.2.7. Example

        11.3. Schema-based AOP support

            11.3.1. Declaring an aspect
            11.3.2. Declaring a pointcut
            11.3.3. Declaring advice

                Before advice
                After returning advice
                After throwing advice
                After (finally) advice
                Around advice
                Advice parameters
                Advice ordering

            11.3.4. Introductions
            11.3.5. Aspect instantiation models
            11.3.6. Advisors
            11.3.7. Example

        11.4. Choosing which AOP declaration style to use

            11.4.1. Spring AOP or full AspectJ?
            11.4.2. @AspectJ or XML for Spring AOP?

        11.5. Mixing aspect types
        11.6. Proxying mechanisms

            11.6.1. Understanding AOP proxies

        11.7. Programmatic creation of @AspectJ Proxies
        11.8. Using AspectJ with Spring applications

            11.8.1. Using AspectJ to dependency inject domain objects with Spring

                Unit testing @Configurable objects
                Working with multiple application contexts

            11.8.2. Other Spring aspects for AspectJ
            11.8.3. Configuring AspectJ aspects using Spring IoC
            11.8.4. Load-time weaving with AspectJ in the Spring Framework

                A first example
                Aspects
                'META-INF/aop.xml'
                Required libraries (JARS)
                Spring configuration
                Environment-specific configuration

        11.9. Further Resources

    12. Spring AOP APIs

        12.1. Introduction
        12.2. Pointcut API in Spring

            12.2.1. Concepts
            12.2.2. Operations on pointcuts
            12.2.3. AspectJ expression pointcuts
            12.2.4. Convenience pointcut implementations

                Static pointcuts
                Dynamic pointcuts

            12.2.5. Pointcut superclasses
            12.2.6. Custom pointcuts

        12.3. Advice API in Spring

            12.3.1. Advice lifecycles
            12.3.2. Advice types in Spring

                Interception around advice
                Before advice
                Throws advice
                After Returning advice
                Introduction advice

        12.4. Advisor API in Spring
        12.5. Using the ProxyFactoryBean to create AOP proxies

            12.5.1. Basics
            12.5.2. JavaBean properties
            12.5.3. JDK- and CGLIB-based proxies
            12.5.4. Proxying interfaces
            12.5.5. Proxying classes
            12.5.6. Using 'global' advisors

        12.6. Concise proxy definitions
        12.7. Creating AOP proxies programmatically with the ProxyFactory
        12.8. Manipulating advised objects
        12.9. Using the "auto-proxy" facility

            12.9.1. Autoproxy bean definitions

                BeanNameAutoProxyCreator
                DefaultAdvisorAutoProxyCreator
                AbstractAdvisorAutoProxyCreator

            12.9.2. Using metadata-driven auto-proxying

        12.10. Using TargetSources

            12.10.1. Hot swappable target sources
            12.10.2. Pooling target sources
            12.10.3. Prototype target sources
            12.10.4. ThreadLocal target sources

        12.11. Defining new Advice types
        12.12. Further resources

IV. 测试

    13. Introduction to Spring Testing
    14. Unit Testing

        14.1. Mock Objects

            14.1.1. Environment
            14.1.2. JNDI
            14.1.3. Servlet API
            14.1.4. Portlet API

        14.2. Unit Testing support Classes

            14.2.1. General testing utilities
            14.2.2. Spring MVC

    15. Integration Testing

        15.1. Overview
        15.2. Goals of Integration Testing

            15.2.1. Context management and caching
            15.2.2. Dependency Injection of test fixtures
            15.2.3. Transaction management
            15.2.4. Support classes for integration testing

        15.3. JDBC Testing Support
        15.4. Annotations

            15.4.1. Spring Testing Annotations

                @BootstrapWith
                @ContextConfiguration
                @WebAppConfiguration
                @ContextHierarchy
                @ActiveProfiles
                @TestPropertySource
                @DirtiesContext
                @TestExecutionListeners
                @Commit
                @Rollback
                @BeforeTransaction
                @AfterTransaction
                @Sql
                @SqlConfig
                @SqlGroup

            15.4.2. Standard Annotation Support
            15.4.3. Spring JUnit 4 Testing Annotations

                @IfProfileValue
                @ProfileValueSourceConfiguration
                @Timed
                @Repeat

            15.4.4. Meta-Annotation Support for Testing

        15.5. Spring TestContext Framework

            15.5.1. Key abstractions

                TestContext
                TestContextManager
                TestExecutionListener
                Context Loaders

            15.5.2. Bootstrapping the TestContext framework
            15.5.3. TestExecutionListener configuration

                Registering custom TestExecutionListeners
                Automatic discovery of default TestExecutionListeners
                Ordering TestExecutionListeners
                Merging TestExecutionListeners

            15.5.4. Context management

                Context configuration with XML resources
                Context configuration with Groovy scripts
                Context configuration with annotated classes
                Mixing XML, Groovy scripts, and annotated classes
                Context configuration with context initializers
                Context configuration inheritance
                Context configuration with environment profiles
                Context configuration with test property sources
                Loading a WebApplicationContext
                Context caching
                Context hierarchies

            15.5.5. Dependency injection of test fixtures
            15.5.6. Testing request and session scoped beans
            15.5.7. Transaction management

                Test-managed transactions
                Enabling and disabling transactions
                Transaction rollback and commit behavior
                Programmatic transaction management
                Executing code outside of a transaction
                Configuring a transaction manager
                Demonstration of all transaction-related annotations

            15.5.8. Executing SQL scripts

                Executing SQL scripts programmatically
                Executing SQL scripts declaratively with @Sql

            15.5.9. TestContext Framework support classes

                Spring JUnit 4 Runner
                Spring JUnit 4 Rules
                JUnit 4 support classes
                TestNG support classes

        15.6. Spring MVC Test Framework

            15.6.1. Server-Side Tests

                Static Imports
                Setup Options
                Performing Requests
                Defining Expectations
                Filter Registrations
                Differences between Out-of-Container and End-to-End Integration Tests
                Further Server-Side Test Examples

            15.6.2. HtmlUnit Integration

                Why HtmlUnit Integration?
                MockMvc and HtmlUnit
                MockMvc and WebDriver
                MockMvc and Geb

            15.6.3. Client-Side REST Tests

                Static Imports
                Further Examples of Client-side REST Tests

        15.7. PetClinic Example

    16. Further Resources

V. 数据访问

    17. 事务管理

        17.1. Introduction to Spring Framework transaction management
        17.2. Advantages of the Spring Framework??s transaction support model

            17.2.1. Global transactions
            17.2.2. Local transactions
            17.2.3. Spring Framework??s consistent programming model

        17.3. Understanding the Spring Framework transaction abstraction
        17.4. Synchronizing resources with transactions

            17.4.1. High-level synchronization approach
            17.4.2. Low-level synchronization approach
            17.4.3. TransactionAwareDataSourceProxy

        17.5. Declarative transaction management

            17.5.1. Understanding the Spring Framework??s declarative transaction implementation
            17.5.2. Example of declarative transaction implementation
            17.5.3. Rolling back a declarative transaction
            17.5.4. Configuring different transactional semantics for different beans
            17.5.5. <tx:advice/> settings
            17.5.6. Using @Transactional

                @Transactional settings
                Multiple Transaction Managers with @Transactional
                Custom shortcut annotations

            17.5.7. Transaction propagation

                Required
                RequiresNew
                Nested

            17.5.8. Advising transactional operations
            17.5.9. Using @Transactional with AspectJ

        17.6. Programmatic transaction management

            17.6.1. Using the TransactionTemplate

                Specifying transaction settings

            17.6.2. Using the PlatformTransactionManager

        17.7. Choosing between programmatic and declarative transaction management
        17.8. Transaction bound event
        17.9. Application server-specific integration

            17.9.1. IBM WebSphere
            17.9.2. Oracle WebLogic Server

        17.10. Solutions to common problems

            17.10.1. Use of the wrong transaction manager for a specific DataSource

        17.11. Further Resources

    18. DAO 支持

        18.1. Introduction
        18.2. Consistent exception hierarchy
        18.3. Annotations used for configuring DAO or Repository classes

    19. 以 JDBC 方式访问数据

        19.1. Introduction to Spring Framework JDBC

            19.1.1. Choosing an approach for JDBC database access
            19.1.2. Package hierarchy

        19.2. Using the JDBC core classes to control basic JDBC processing and error handling

            19.2.1. JdbcTemplate

                Examples of JdbcTemplate class usage
                JdbcTemplate best practices

            19.2.2. NamedParameterJdbcTemplate
            19.2.3. SQLExceptionTranslator
            19.2.4. Executing statements
            19.2.5. Running queries
            19.2.6. Updating the database
            19.2.7. Retrieving auto-generated keys

        19.3. Controlling database connections

            19.3.1. DataSource
            19.3.2. DataSourceUtils
            19.3.3. SmartDataSource
            19.3.4. AbstractDataSource
            19.3.5. SingleConnectionDataSource
            19.3.6. DriverManagerDataSource
            19.3.7. TransactionAwareDataSourceProxy
            19.3.8. DataSourceTransactionManager
            19.3.9. NativeJdbcExtractor

        19.4. JDBC batch operations

            19.4.1. Basic batch operations with the JdbcTemplate
            19.4.2. Batch operations with a List of objects
            19.4.3. Batch operations with multiple batches

        19.5. Simplifying JDBC operations with the SimpleJdbc classes

            19.5.1. Inserting data using SimpleJdbcInsert
            19.5.2. Retrieving auto-generated keys using SimpleJdbcInsert
            19.5.3. Specifying columns for a SimpleJdbcInsert
            19.5.4. Using SqlParameterSource to provide parameter values
            19.5.5. Calling a stored procedure with SimpleJdbcCall
            19.5.6. Explicitly declaring parameters to use for a SimpleJdbcCall
            19.5.7. How to define SqlParameters
            19.5.8. Calling a stored function using SimpleJdbcCall
            19.5.9. Returning ResultSet/REF Cursor from a SimpleJdbcCall

        19.6. Modeling JDBC operations as Java objects

            19.6.1. SqlQuery
            19.6.2. MappingSqlQuery
            19.6.3. SqlUpdate
            19.6.4. StoredProcedure

        19.7. Common problems with parameter and data value handling

            19.7.1. Providing SQL type information for parameters
            19.7.2. Handling BLOB and CLOB objects
            19.7.3. Passing in lists of values for IN clause
            19.7.4. Handling complex types for stored procedure calls

        19.8. Embedded database support

            19.8.1. Why use an embedded database?
            19.8.2. Creating an embedded database using Spring XML
            19.8.3. Creating an embedded database programmatically
            19.8.4. Selecting the embedded database type

                Using HSQL
                Using H2
                Using Derby

            19.8.5. Testing data access logic with an embedded database
            19.8.6. Generating unique names for embedded databases
            19.8.7. Extending the embedded database support

        19.9. Initializing a DataSource

            19.9.1. Initializing a database using Spring XML

                Initialization of other components that depend on the database

    20. 以 ORM 方式访问数据

        20.1. Introduction to ORM with Spring
        20.2. General ORM integration considerations

            20.2.1. Resource and transaction management
            20.2.2. Exception translation

        20.3. Hibernate

            20.3.1. SessionFactory setup in a Spring container
            20.3.2. Implementing DAOs based on plain Hibernate API
            20.3.3. Declarative transaction demarcation
            20.3.4. Programmatic transaction demarcation
            20.3.5. Transaction management strategies
            20.3.6. Comparing container-managed and locally defined resources
            20.3.7. Spurious application server warnings with Hibernate

        20.4. JDO

            20.4.1. PersistenceManagerFactory setup
            20.4.2. Implementing DAOs based on the plain JDO API
            20.4.3. Transaction management
            20.4.4. JdoDialect

        20.5. JPA

            20.5.1. Three options for JPA setup in a Spring environment

                LocalEntityManagerFactoryBean
                Obtaining an EntityManagerFactory from JNDI
                LocalContainerEntityManagerFactoryBean
                Dealing with multiple persistence units

            20.5.2. Implementing DAOs based on JPA: EntityManagerFactory and EntityManager
            20.5.3. Spring-driven JPA transactions
            20.5.4. JpaDialect and JpaVendorAdapter
            20.5.5. Setting up JPA with JTA transaction management

    21. Marshalling XML using O/X Mappers

        21.1. Introduction

            21.1.1. Ease of configuration
            21.1.2. Consistent Interfaces
            21.1.3. Consistent Exception Hierarchy

        21.2. Marshaller and Unmarshaller

            21.2.1. Marshaller
            21.2.2. Unmarshaller
            21.2.3. XmlMappingException

        21.3. Using Marshaller and Unmarshaller
        21.4. XML Schema-based Configuration
        21.5. JAXB

            21.5.1. Jaxb2Marshaller

                XML Schema-based Configuration

        21.6. Castor

            21.6.1. CastorMarshaller
            21.6.2. Mapping

                XML Schema-based Configuration

        21.7. XMLBeans

            21.7.1. XmlBeansMarshaller

                XML Schema-based Configuration

        21.8. JiBX

            21.8.1. JibxMarshaller

                XML Schema-based Configuration

        21.9. XStream

            21.9.1. XStreamMarshaller

VI. Web

    22. MVC框架

        22.1. Introduction to Spring Web MVC framework

            22.1.1. Features of Spring Web MVC
            22.1.2. Pluggability of other MVC implementations

        22.2. The DispatcherServlet

            22.2.1. Special Bean Types In the WebApplicationContext
            22.2.2. Default DispatcherServlet Configuration
            22.2.3. DispatcherServlet Processing Sequence

        22.3. Implementing Controllers

            22.3.1. Defining a controller with @Controller
            22.3.2. Mapping Requests With @RequestMapping

                Composed @RequestMapping Variants
                @Controller and AOP Proxying
                New Support Classes for @RequestMapping methods in Spring MVC 3.1
                URI Template Patterns
                URI Template Patterns with Regular Expressions
                Path Patterns
                Path Pattern Comparison
                Path Patterns with Placeholders
                Suffix Pattern Matching
                Suffix Pattern Matching and RFD
                Matrix Variables
                Consumable Media Types
                Producible Media Types
                Request Parameters and Header Values
                HTTP HEAD and HTTP OPTIONS

            22.3.3. Defining @RequestMapping handler methods

                Supported method argument types
                Supported method return types
                Binding request parameters to method parameters with @RequestParam
                Mapping the request body with the @RequestBody annotation
                Mapping the response body with the @ResponseBody annotation
                Creating REST Controllers with the @RestController annotation
                Using HttpEntity
                Using @ModelAttribute on a method
                Using @ModelAttribute on a method argument
                Using @SessionAttributes to store model attributes in the HTTP session between requests
                Using @SessionAttribute to access pre-existing global session attributes
                Using @RequestAttribute to access request attributes
                Working with "application/x-www-form-urlencoded" data
                Mapping cookie values with the @CookieValue annotation
                Mapping request header attributes with the @RequestHeader annotation
                Method Parameters And Type Conversion
                Customizing WebDataBinder initialization
                Advising controllers with @ControllerAdvice and @RestControllerAdvice
                Jackson Serialization View Support
                Jackson JSONP Support

            22.3.4. Asynchronous Request Processing

                Exception Handling for Async Requests
                Intercepting Async Requests
                HTTP Streaming
                HTTP Streaming With Server-Sent Events
                HTTP Streaming Directly To The OutputStream
                Configuring Asynchronous Request Processing

            22.3.5. Testing Controllers

        22.4. Handler mappings

            22.4.1. Intercepting requests with a HandlerInterceptor

        22.5. Resolving views

            22.5.1. Resolving views with the ViewResolver interface
            22.5.2. Chaining ViewResolvers
            22.5.3. Redirecting to Views

                RedirectView
                The redirect: prefix
                The forward: prefix

            22.5.4. ContentNegotiatingViewResolver

        22.6. Using flash attributes
        22.7. Building URIs

            22.7.1. Building URIs to Controllers and methods
            22.7.2. Building URIs to Controllers and methods from views

        22.8. Using locales

            22.8.1. Obtaining Time Zone Information
            22.8.2. AcceptHeaderLocaleResolver
            22.8.3. CookieLocaleResolver
            22.8.4. SessionLocaleResolver
            22.8.5. LocaleChangeInterceptor

        22.9. Using themes

            22.9.1. Overview of themes
            22.9.2. Defining themes
            22.9.3. Theme resolvers

        22.10. Spring??s multipart (file upload) support

            22.10.1. Introduction
            22.10.2. Using a MultipartResolver with Commons FileUpload
            22.10.3. Using a MultipartResolver with Servlet 3.0
            22.10.4. Handling a file upload in a form
            22.10.5. Handling a file upload request from programmatic clients

        22.11. Handling exceptions

            22.11.1. HandlerExceptionResolver
            22.11.2. @ExceptionHandler
            22.11.3. Handling Standard Spring MVC Exceptions
            22.11.4. Annotating Business Exceptions With @ResponseStatus
            22.11.5. Customizing the Default Servlet Container Error Page

        22.12. Web Security
        22.13. Convention over configuration support

            22.13.1. The Controller ControllerClassNameHandlerMapping
            22.13.2. The Model ModelMap (ModelAndView)
            22.13.3. The View - RequestToViewNameTranslator

        22.14. HTTP caching support

            22.14.1. Cache-Control HTTP header
            22.14.2. HTTP caching support for static resources
            22.14.3. Support for the Cache-Control, ETag and Last-Modified response headers in Controllers
            22.14.4. Shallow ETag support

        22.15. Code-based Servlet container initialization
        22.16. Configuring Spring MVC

            22.16.1. Enabling the MVC Java Config or the MVC XML Namespace
            22.16.2. Customizing the Provided Configuration
            22.16.3. Conversion and Formatting
            22.16.4. Validation
            22.16.5. Interceptors
            22.16.6. Content Negotiation
            22.16.7. View Controllers
            22.16.8. View Resolvers
            22.16.9. Serving of Resources
            22.16.10. Falling Back On the "Default" Servlet To Serve Resources
            22.16.11. Path Matching
            22.16.12. Message Converters
            22.16.13. Advanced Customizations with MVC Java Config
            22.16.14. Advanced Customizations with the MVC Namespace

    23. View technologies

        23.1. Introduction
        23.2. Thymeleaf
        23.3. Groovy Markup Templates

            23.3.1. Configuration
            23.3.2. Example

        23.4. Velocity & FreeMarker

            23.4.1. Dependencies
            23.4.2. Context configuration
            23.4.3. Creating templates
            23.4.4. Advanced configuration

                velocity.properties
                FreeMarker

            23.4.5. Bind support and form handling

                The bind macros
                Simple binding
                Form input generation macros
                HTML escaping and XHTML compliance

        23.5. JSP & JSTL

            23.5.1. View resolvers
            23.5.2. 'Plain-old' JSPs versus JSTL
            23.5.3. Additional tags facilitating development
            23.5.4. Using Spring??s form tag library

                Configuration
                The form tag
                The input tag
                The checkbox tag
                The checkboxes tag
                The radiobutton tag
                The radiobuttons tag
                The password tag
                The select tag
                The option tag
                The options tag
                The textarea tag
                The hidden tag
                The errors tag
                HTTP Method Conversion
                HTML5 Tags

        23.6. Script templates

            23.6.1. Dependencies
            23.6.2. How to integrate script based templating

        23.7. XML Marshalling View
        23.8. Tiles

            23.8.1. Dependencies
            23.8.2. How to integrate Tiles

                UrlBasedViewResolver
                ResourceBundleViewResolver
                SimpleSpringPreparerFactory and SpringBeanPreparerFactory

        23.9. XSLT

            23.9.1. My First Words

                Bean definitions
                Standard MVC controller code
                Document transformation

        23.10. Document views (PDF/Excel)

            23.10.1. Introduction
            23.10.2. Configuration and setup

                Document view definitions
                Controller code
                Subclassing for Excel views
                Subclassing for PDF views

        23.11. JasperReports

            23.11.1. Dependencies
            23.11.2. Configuration

                Configuring the ViewResolver
                Configuring the Views
                About Report Files
                Using JasperReportsMultiFormatView

            23.11.3. Populating the ModelAndView
            23.11.4. Working with Sub-Reports

                Configuring Sub-Report Files
                Configuring Sub-Report Data Sources

            23.11.5. Configuring Exporter Parameters

        23.12. Feed Views
        23.13. JSON Mapping View
        23.14. XML Mapping View

    24. Integrating with other web frameworks

        24.1. Introduction
        24.2. Common configuration
        24.3. JavaServer Faces 1.2

            24.3.1. SpringBeanFacesELResolver (JSF 1.2+)
            24.3.2. FacesContextUtils

        24.4. Apache Struts 2.x
        24.5. Tapestry 5.x
        24.6. Further Resources

    25. Portlet MVC Framework

        25.1. Introduction

            25.1.1. Controllers - The C in MVC
            25.1.2. Views - The V in MVC
            25.1.3. Web-scoped beans

        25.2. The DispatcherPortlet
        25.3. The ViewRendererServlet
        25.4. Controllers

            25.4.1. AbstractController and PortletContentGenerator
            25.4.2. Other simple controllers
            25.4.3. Command Controllers
            25.4.4. PortletWrappingController

        25.5. Handler mappings

            25.5.1. PortletModeHandlerMapping
            25.5.2. ParameterHandlerMapping
            25.5.3. PortletModeParameterHandlerMapping
            25.5.4. Adding HandlerInterceptors
            25.5.5. HandlerInterceptorAdapter
            25.5.6. ParameterMappingInterceptor

        25.6. Views and resolving them
        25.7. Multipart (file upload) support

            25.7.1. Using the PortletMultipartResolver
            25.7.2. Handling a file upload in a form

        25.8. Handling exceptions
        25.9. Annotation-based controller configuration

            25.9.1. Setting up the dispatcher for annotation support
            25.9.2. Defining a controller with @Controller
            25.9.3. Mapping requests with @RequestMapping
            25.9.4. Supported handler method arguments
            25.9.5. Binding request parameters to method parameters with @RequestParam
            25.9.6. Providing a link to data from the model with @ModelAttribute
            25.9.7. Specifying attributes to store in a Session with @SessionAttributes
            25.9.8. Customizing WebDataBinder initialization

                Customizing data binding with @InitBinder
                Configuring a custom WebBindingInitializer

        25.10. Portlet application deployment

    26. WebSocket Support

        26.1. Introduction

            26.1.1. WebSocket Fallback Options
            26.1.2. A Messaging Architecture
            26.1.3. Sub-Protocol Support in WebSocket
            26.1.4. Should I Use WebSocket?

        26.2. WebSocket API

            26.2.1. Create and Configure a WebSocketHandler
            26.2.2. Customizing the WebSocket Handshake
            26.2.3. WebSocketHandler Decoration
            26.2.4. Deployment Considerations
            26.2.5. Configuring the WebSocket Engine
            26.2.6. Configuring allowed origins

        26.3. SockJS Fallback Options

            26.3.1. Overview of SockJS
            26.3.2. Enable SockJS
            26.3.3. HTTP Streaming in IE 8, 9: Ajax/XHR vs IFrame
            26.3.4. Heartbeat Messages
            26.3.5. Servlet 3 Async Requests
            26.3.6. CORS Headers for SockJS
            26.3.7. SockJS Client

        26.4. STOMP Over WebSocket Messaging Architecture

            26.4.1. Overview of STOMP
            26.4.2. Enable STOMP over WebSocket
            26.4.3. Flow of Messages
            26.4.4. Annotation Message Handling
            26.4.5. Sending Messages
            26.4.6. Simple Broker
            26.4.7. Full-Featured Broker
            26.4.8. Connections To Full-Featured Broker
            26.4.9. Using Dot as Separator in @MessageMapping Destinations
            26.4.10. Authentication
            26.4.11. Token-based Authentication
            26.4.12. User Destinations
            26.4.13. Listening To ApplicationContext Events and Intercepting Messages
            26.4.14. STOMP Client
            26.4.15. WebSocket Scope
            26.4.16. Configuration and Performance
            26.4.17. Runtime Monitoring
            26.4.18. Testing Annotated Controller Methods

    27. CORS Support

        27.1. Introduction
        27.2. Controller method CORS configuration
        27.3. Global CORS configuration

            27.3.1. JavaConfig
            27.3.2. XML namespace

        27.4. Advanced Customization
        27.5. Filter based CORS support

VII. Integration

    28. Remoting and web services using Spring

        28.1. Introduction
        28.2. Exposing services using RMI

            28.2.1. Exporting the service using the RmiServiceExporter
            28.2.2. Linking in the service at the client

        28.3. Using Hessian or Burlap to remotely call services via HTTP

            28.3.1. Wiring up the DispatcherServlet for Hessian and co.
            28.3.2. Exposing your beans by using the HessianServiceExporter
            28.3.3. Linking in the service on the client
            28.3.4. Using Burlap
            28.3.5. Applying HTTP basic authentication to a service exposed through Hessian or Burlap

        28.4. Exposing services using HTTP invokers

            28.4.1. Exposing the service object
            28.4.2. Linking in the service at the client

        28.5. Web services

            28.5.1. Exposing servlet-based web services using JAX-WS
            28.5.2. Exporting standalone web services using JAX-WS
            28.5.3. Exporting web services using the JAX-WS RI??s Spring support
            28.5.4. Accessing web services using JAX-WS

        28.6. JMS

            28.6.1. Server-side configuration
            28.6.2. Client-side configuration

        28.7. AMQP
        28.8. Auto-detection is not implemented for remote interfaces
        28.9. Considerations when choosing a technology
        28.10. Accessing RESTful services on the Client

            28.10.1. RestTemplate

                Working with the URI
                Dealing with request and response headers
                Jackson JSON Views support

            28.10.2. HTTP Message Conversion

                StringHttpMessageConverter
                FormHttpMessageConverter
                ByteArrayHttpMessageConverter
                MarshallingHttpMessageConverter
                MappingJackson2HttpMessageConverter
                MappingJackson2XmlHttpMessageConverter
                SourceHttpMessageConverter
                BufferedImageHttpMessageConverter

            28.10.3. Async RestTemplate

    29. Enterprise JavaBeans (EJB) integration

        29.1. Introduction
        29.2. Accessing EJBs

            29.2.1. Concepts
            29.2.2. Accessing local SLSBs
            29.2.3. Accessing remote SLSBs
            29.2.4. Accessing EJB 2.x SLSBs versus EJB 3 SLSBs

        29.3. Using Spring??s EJB implementation support classes

            29.3.1. EJB 3 injection interceptor

    30. JMS (Java Message Service)

        30.1. Introduction
        30.2. Using Spring JMS

            30.2.1. JmsTemplate
            30.2.2. Connections

                Caching Messaging Resources
                SingleConnectionFactory
                CachingConnectionFactory

            30.2.3. Destination Management
            30.2.4. Message Listener Containers

                SimpleMessageListenerContainer
                DefaultMessageListenerContainer

            30.2.5. Transaction management

        30.3. Sending a Message

            30.3.1. Using Message Converters
            30.3.2. SessionCallback and ProducerCallback

        30.4. Receiving a message

            30.4.1. Synchronous Reception
            30.4.2. Asynchronous Reception - Message-Driven POJOs
            30.4.3. the SessionAwareMessageListener interface
            30.4.4. the MessageListenerAdapter
            30.4.5. Processing messages within transactions

        30.5. Support for JCA Message Endpoints
        30.6. Annotation-driven listener endpoints

            30.6.1. Enable listener endpoint annotations
            30.6.2. Programmatic endpoints registration
            30.6.3. Annotated endpoint method signature
            30.6.4. Response management

        30.7. JMS namespace support

    31. JMX

        31.1. Introduction
        31.2. Exporting your beans to JMX

            31.2.1. Creating an MBeanServer
            31.2.2. Reusing an existing MBeanServer
            31.2.3. Lazy-initialized MBeans
            31.2.4. Automatic registration of MBeans
            31.2.5. Controlling the registration behavior

        31.3. Controlling the management interface of your beans

            31.3.1. the MBeanInfoAssembler Interface
            31.3.2. Using Source-Level Metadata (Java annotations)
            31.3.3. Source-Level Metadata Types
            31.3.4. the AutodetectCapableMBeanInfoAssembler interface
            31.3.5. Defining management interfaces using Java interfaces
            31.3.6. Using MethodNameBasedMBeanInfoAssembler

        31.4. Controlling the ObjectNames for your beans

            31.4.1. Reading ObjectNames from Properties
            31.4.2. Using the MetadataNamingStrategy
            31.4.3. Configuring annotation based MBean export

        31.5. JSR-160 Connectors

            31.5.1. Server-side Connectors
            31.5.2. Client-side Connectors
            31.5.3. JMX over Burlap/Hessian/SOAP

        31.6. Accessing MBeans via Proxies
        31.7. Notifications

            31.7.1. Registering Listeners for Notifications
            31.7.2. Publishing Notifications

        31.8. Further Resources

    32. JCA CCI

        32.1. Introduction
        32.2. Configuring CCI

            32.2.1. Connector configuration
            32.2.2. ConnectionFactory configuration in Spring
            32.2.3. Configuring CCI connections
            32.2.4. Using a single CCI connection

        32.3. Using Spring??s CCI access support

            32.3.1. Record conversion
            32.3.2. the CciTemplate
            32.3.3. DAO support
            32.3.4. Automatic output record generation
            32.3.5. Summary
            32.3.6. Using a CCI Connection and Interaction directly
            32.3.7. Example for CciTemplate usage

        32.4. Modeling CCI access as operation objects

            32.4.1. MappingRecordOperation
            32.4.2. MappingCommAreaOperation
            32.4.3. Automatic output record generation
            32.4.4. Summary
            32.4.5. Example for MappingRecordOperation usage
            32.4.6. Example for MappingCommAreaOperation usage

        32.5. Transactions

    33. Email

        33.1. Introduction
        33.2. Usage

            33.2.1. Basic MailSender and SimpleMailMessage usage
            33.2.2. Using the JavaMailSender and the MimeMessagePreparator

        33.3. Using the JavaMail MimeMessageHelper

            33.3.1. Sending attachments and inline resources

                Attachments
                Inline resources

            33.3.2. Creating email content using a templating library

                A Velocity-based example

    34. Task Execution and Scheduling

        34.1. Introduction
        34.2. The Spring TaskExecutor abstraction

            34.2.1. TaskExecutor types
            34.2.2. Using a TaskExecutor

        34.3. The Spring TaskScheduler abstraction

            34.3.1. the Trigger interface
            34.3.2. Trigger implementations
            34.3.3. TaskScheduler implementations

        34.4. Annotation Support for Scheduling and Asynchronous Execution

            34.4.1. Enable scheduling annotations
            34.4.2. The @Scheduled annotation
            34.4.3. The @Async annotation
            34.4.4. Executor qualification with @Async
            34.4.5. Exception management with @Async

        34.5. The task namespace

            34.5.1. The 'scheduler' element
            34.5.2. The 'executor' element
            34.5.3. The 'scheduled-tasks' element

        34.6. Using the Quartz Scheduler

            34.6.1. Using the JobDetailFactoryBean
            34.6.2. Using the MethodInvokingJobDetailFactoryBean
            34.6.3. Wiring up jobs using triggers and the SchedulerFactoryBean

    35. Dynamic language support

        35.1. Introduction
        35.2. A first example
        35.3. Defining beans that are backed by dynamic languages

            35.3.1. Common concepts

                The <lang:language/> element
                Refreshable beans
                Inline dynamic language source files
                Understanding Constructor Injection in the context of dynamic-language-backed beans

            35.3.2. JRuby beans
            35.3.3. Groovy beans

                Customizing Groovy objects via a callback

            35.3.4. BeanShell beans

        35.4. Scenarios

            35.4.1. Scripted Spring MVC Controllers
            35.4.2. Scripted Validators

        35.5. Bits and bobs

            35.5.1. AOP - advising scripted beans
            35.5.2. Scoping

        35.6. Further Resources

    36. Cache Abstraction

        36.1. Introduction
        36.2. Understanding the cache abstraction
        36.3. Declarative annotation-based caching

            36.3.1. @Cacheable annotation

                Default Key Generation
                Custom Key Generation Declaration
                Default Cache Resolution
                Custom cache resolution
                Synchronized caching
                Conditional caching
                Available caching SpEL evaluation context

            36.3.2. @CachePut annotation
            36.3.3. @CacheEvict annotation
            36.3.4. @Caching annotation
            36.3.5. @CacheConfig annotation
            36.3.6. Enable caching annotations
            36.3.7. Using custom annotations

        36.4. JCache (JSR-107) annotations

            36.4.1. Features summary
            36.4.2. Enabling JSR-107 support

        36.5. Declarative XML-based caching
        36.6. Configuring the cache storage

            36.6.1. JDK ConcurrentMap-based Cache
            36.6.2. Ehcache-based Cache
            36.6.3. Caffeine Cache
            36.6.4. Guava Cache
            36.6.5. GemFire-based Cache
            36.6.6. JSR-107 Cache
            36.6.7. Dealing with caches without a backing store

        36.7. Plugging-in different back-end caches
        36.8. How can I set the TTL/TTI/Eviction policy/XXX feature?

VIII. Appendices

    37. Migrating to Spring Framework 4.x
    38. Spring Annotation Programming Model
    39. Classic Spring Usage

        39.1. Classic ORM usage

            39.1.1. Hibernate

                The HibernateTemplate
                Implementing Spring-based DAOs without callbacks

        39.2. JMS Usage

            39.2.1. JmsTemplate
            39.2.2. Asynchronous Message Reception
            39.2.3. Connections
            39.2.4. Transaction Management

    40. Classic Spring AOP Usage

        40.1. Pointcut API in Spring

            40.1.1. Concepts
            40.1.2. Operations on pointcuts
            40.1.3. AspectJ expression pointcuts
            40.1.4. Convenience pointcut implementations

                Static pointcuts
                Dynamic pointcuts

            40.1.5. Pointcut superclasses
            40.1.6. Custom pointcuts

        40.2. Advice API in Spring

            40.2.1. Advice lifecycles
            40.2.2. Advice types in Spring

                Interception around advice
                Before advice
                Throws advice
                After Returning advice
                Introduction advice

        40.3. Advisor API in Spring
        40.4. Using the ProxyFactoryBean to create AOP proxies

            40.4.1. Basics
            40.4.2. JavaBean properties
            40.4.3. JDK- and CGLIB-based proxies
            40.4.4. Proxying interfaces
            40.4.5. Proxying classes
            40.4.6. Using 'global' advisors

        40.5. Concise proxy definitions
        40.6. Creating AOP proxies programmatically with the ProxyFactory
        40.7. Manipulating advised objects
        40.8. Using the "autoproxy" facility

            40.8.1. Autoproxy bean definitions

                BeanNameAutoProxyCreator
                DefaultAdvisorAutoProxyCreator
                AbstractAdvisorAutoProxyCreator

            40.8.2. Using metadata-driven auto-proxying

        40.9. Using TargetSources

            40.9.1. Hot swappable target sources
            40.9.2. Pooling target sources
            40.9.3. Prototype target sources
            40.9.4. ThreadLocal target sources

        40.10. Defining new Advice types
        40.11. Further resources

    41. XML Schema-based configuration

        41.1. Introduction
        41.2. XML Schema-based configuration

            41.2.1. Referencing the schemas
            41.2.2. the util schema

                <util:constant/>
                <util:property-path/>
                <util:properties/>
                <util:list/>
                <util:map/>
                <util:set/>

            41.2.3. the jee schema

                <jee:jndi-lookup/> (simple)
                <jee:jndi-lookup/> (with single JNDI environment setting)
                <jee:jndi-lookup/> (with multiple JNDI environment settings)
                <jee:jndi-lookup/> (complex)
                <jee:local-slsb/> (simple)
                <jee:local-slsb/> (complex)
                <jee:remote-slsb/>

            41.2.4. the lang schema
            41.2.5. the jms schema
            41.2.6. the tx (transaction) schema
            41.2.7. the aop schema
            41.2.8. the context schema

                <property-placeholder/>
                <annotation-config/>
                <component-scan/>
                <load-time-weaver/>
                <spring-configured/>
                <mbean-export/>

            41.2.9. the tool schema
            41.2.10. the jdbc schema
            41.2.11. the cache schema
            41.2.12. the beans schema

    42. Extensible XML authoring

        42.1. Introduction
        42.2. Authoring the schema
        42.3. Coding a NamespaceHandler
        42.4. BeanDefinitionParser
        42.5. Registering the handler and the schema

            42.5.1. 'META-INF/spring.handlers'
            42.5.2. 'META-INF/spring.schemas'

        42.6. Using a custom extension in your Spring XML configuration
        42.7. Meatier examples

            42.7.1. Nesting custom tags within custom tags
            42.7.2. Custom attributes on 'normal' elements

        42.8. Further Resources

    43. spring JSP Tag Library

        43.1. Introduction
        43.2. The argument tag
        43.3. The bind tag
        43.4. The escapeBody tag
        43.5. The eval tag
        43.6. The hasBindErrors tag
        43.7. The htmlEscape tag
        43.8. The message tag
        43.9. The nestedPath tag
        43.10. The param tag
        43.11. The theme tag
        43.12. The transform tag
        43.13. The url tag

    44. spring-form JSP Tag Library

        44.1. Introduction
        44.2. The button tag
        44.3. The checkbox tag
        44.4. The checkboxes tag
        44.5. The errors tag
        44.6. The form tag
        44.7. The hidden tag
        44.8. The input tag
        44.9. The label tag
        44.10. The option tag
        44.11. The options tag
        44.12. The password tag
        44.13. The radiobutton tag
        44.14. The radiobuttons tag
        44.15. The select tag
        44.16. The textarea tag
